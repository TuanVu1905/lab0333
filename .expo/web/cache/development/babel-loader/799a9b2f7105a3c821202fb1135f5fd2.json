{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport axios from 'axios';\nimport { BASE_URL } from \"../../utils\";\nexport var onAvailability = function onAvailability(postCode) {\n  return function _callee(dispatch) {\n    var response;\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return _regeneratorRuntime.awrap(axios.get(BASE_URL + \"food/availability/123456\"));\n\n          case 3:\n            response = _context.sent;\n\n            if (!response) {\n              dispatch({\n                type: 'ON_SHOPPING_ERROR',\n                payload: 'Availability error'\n              });\n            } else {\n              dispatch({\n                type: 'ON_SHOPPING_AVAILABILITY',\n                payload: response.data\n              });\n            }\n\n            _context.next = 10;\n            break;\n\n          case 7:\n            _context.prev = 7;\n            _context.t0 = _context[\"catch\"](0);\n            dispatch({\n              type: 'ON_SHOPPING_ERROR',\n              payload: _context.t0\n            });\n\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, [[0, 7]], Promise);\n  };\n};\nexport var onSearchFoods = function onSearchFoods(postCode) {\n  return function _callee2(dispatch) {\n    var response;\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return _regeneratorRuntime.awrap(axios.get(BASE_URL + \"food/search/123456\"));\n\n          case 3:\n            response = _context2.sent;\n\n            if (!response) {\n                dispatch({\n                  type: 'ON_SHOPPING_ERROR',\n                  payload: 'Availability error'\n                });\n              } else {\n                dispatch({\n                  type: 'ON_FOOD_SEARCH',\n                  payload: response.data\n                });\n              }\n\n            _context2.next = 10;\n            break;\n\n          case 7:\n            _context2.prev = 7;\n            _context2.t0 = _context2[\"catch\"](0);\n            dispatch({\n              type: 'ON_SHOPPING_ERROR',\n              payload: _context2.t0\n            });\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, [[0, 7]], Promise);\n  };\n};","map":{"version":3,"sources":["D:/NHOM_5_FOOD_ORDERING_17DTHD1/NHOM_5_FOOD_ORDERING_17DTHD1/RN-AppFood/src/redux/actions/shoppingActions.ts"],"names":["axios","BASE_URL","onAvailability","postCode","dispatch","get","response","type","payload","data","onSearchFoods"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;AAEA,SAAQC,QAAR;AAuBA,OAAO,IAAMC,cAAc,GAAG,SAAjBA,cAAiB,CAACC,QAAD,EAAsB;AAGhD,SAAO,iBAAOC,QAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6CAIwBJ,KAAK,CAACK,GAAN,CAA+BJ,QAA/B,8BAJxB;;AAAA;AAIOK,YAAAA,QAJP;;AAMC,gBAAG,CAACA,QAAJ,EAAc;AACVF,cAAAA,QAAQ,CAAC;AACLG,gBAAAA,IAAI,EAAE,mBADD;AAELC,gBAAAA,OAAO,EAAE;AAFJ,eAAD,CAAR;AAIH,aALD,MAKM;AACFJ,cAAAA,QAAQ,CAAC;AACLG,gBAAAA,IAAI,EAAC,0BADA;AAELC,gBAAAA,OAAO,EAAEF,QAAQ,CAACG;AAFb,eAAD,CAAR;AAIH;;AAhBF;AAAA;;AAAA;AAAA;AAAA;AAkBCL,YAAAA,QAAQ,CAAC;AACLG,cAAAA,IAAI,EAAE,mBADD;AAELC,cAAAA,OAAO;AAFF,aAAD,CAAR;;AAlBD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAP;AAwBH,CA3BM;AA6BP,OAAO,IAAME,aAAa,GAAG,SAAhBA,aAAgB,CAACP,QAAD,EAAsB;AAG/C,SAAO,kBAAOC,QAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6CAIwBJ,KAAK,CAACK,GAAN,CAA0BJ,QAA1B,wBAJxB;;AAAA;AAIOK,YAAAA,QAJP;;AAQC,gBAAG,CAACA,QAAJ,EACA;AACIF,gBAAAA,QAAQ,CAAC;AACLG,kBAAAA,IAAI,EAAE,mBADD;AAELC,kBAAAA,OAAO,EAAE;AAFJ,iBAAD,CAAR;AAIH,eAND,MAOA;AACIJ,gBAAAA,QAAQ,CAAC;AACLG,kBAAAA,IAAI,EAAC,gBADA;AAELC,kBAAAA,OAAO,EAAEF,QAAQ,CAACG;AAFb,iBAAD,CAAR;AAIH;;AApBF;AAAA;;AAAA;AAAA;AAAA;AAsBCL,YAAAA,QAAQ,CAAC;AACLG,cAAAA,IAAI,EAAE,mBADD;AAELC,cAAAA,OAAO;AAFF,aAAD,CAAR;;AAtBD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAP;AA4BH,CA/BM","sourcesContent":["import axios from 'axios'\r\nimport {Dispatch} from 'react'\r\nimport {BASE_URL} from '../../utils'\r\nimport { Address } from 'expo-location'\r\nimport { FoodAvailability, FoodModel } from '../models'\r\n\r\n//availability \r\nexport interface AvailabilityAction{\r\n    readonly type: 'ON_SHOPPING_AVAILABILITY',\r\n    payload: FoodAvailability\r\n}\r\n\r\nexport interface FoodSearchAction {\r\n    readonly type: 'ON_FOOD_SEARCH',\r\n    payload:[FoodModel]\r\n}\r\n\r\nexport interface ShoppingErrorAction{\r\n    readonly type: 'ON_SHOPPING_ERROR',\r\n    payload: any\r\n}\r\n\r\nexport type ShoppingAction = AvailabilityAction | ShoppingErrorAction | FoodSearchAction\r\n\r\n\r\nexport const onAvailability = (postCode: string) => {\r\n\r\n\r\n    return async (dispatch: Dispatch<ShoppingAction>) => {\r\n        try {\r\n\r\n            // fetch data từ API\r\n            const response = await axios.get<FoodAvailability>(`${BASE_URL}food/availability/123456`)\r\n            \r\n            if(!response) {\r\n                dispatch({\r\n                    type: 'ON_SHOPPING_ERROR',\r\n                    payload: 'Availability error'\r\n                })\r\n            }else {\r\n                dispatch({\r\n                    type:'ON_SHOPPING_AVAILABILITY',\r\n                    payload: response.data\r\n                })\r\n            }            \r\n        } catch (error) {\r\n            dispatch({\r\n                type: 'ON_SHOPPING_ERROR',\r\n                payload: error\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\nexport const onSearchFoods = (postCode: string) => {\r\n\r\n\r\n    return async (dispatch: Dispatch<ShoppingAction>) => {\r\n        try {\r\n\r\n            // fetch data từ API\r\n            const response = await axios.get<[FoodModel]>(`${BASE_URL}food/search/123456`) \r\n            \r\n            // console.log('lấy dữ liệu', response.data) đã có data\r\n\r\n            if(!response) // nếu dữ liệu ko có \r\n            {\r\n                dispatch({\r\n                    type: 'ON_SHOPPING_ERROR',   // trả về loại : ...\r\n                    payload: 'Availability error' // trả về hành động : ....\r\n                })\r\n            }else // nếu có dữ liệu\r\n            {\r\n                dispatch({                          \r\n                    type:'ON_FOOD_SEARCH',  // trả về loại : ...\r\n                    payload: response.data   // trả về hành động : lấy data\r\n                })\r\n            }            \r\n        } catch (error) {\r\n            dispatch({\r\n                type: 'ON_SHOPPING_ERROR',\r\n                payload: error\r\n            })\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}